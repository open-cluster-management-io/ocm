package v1alpha1

// This file contains a collection of methods that can be used from go-restful to
// generate Swagger API documentation for its models. Please read this PR for more
// information on the implementation: https://github.com/emicklei/go-restful/pull/215
//
// TODOs are ignored from the parser (e.g. TODO(andronat):... || TODO:...) if and only if
// they are on one line! For multiple line or blocks that you want to ignore use ---.
// Any context after a --- is ignored.
//
// Those methods can be generated by using hack/update-swagger-docs.sh

// AUTO-GENERATED FUNCTIONS START HERE
var map_ClusterClaim = map[string]string{
	"":     "ClusterClaim represents cluster information that a managed cluster claims ClusterClaims with well known names include,\n 1. id.k8s.io, it contains a unique identifier for the cluster.\n 2. clusterset.k8s.io, it contains an identifier that relates the cluster\n    to the ClusterSet in which it belongs.\n\nClusterClaims created on a managed cluster will be collected and saved into the status of the corresponding ManagedCluster on hub.",
	"spec": "Spec defines the attributes of the ClusterClaim.",
}

func (ClusterClaim) SwaggerDoc() map[string]string {
	return map_ClusterClaim
}

var map_ClusterClaimList = map[string]string{
	"":         "ClusterClaimList is a collection of ClusterClaim.",
	"metadata": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
	"items":    "Items is a list of ClusterClaim.",
}

func (ClusterClaimList) SwaggerDoc() map[string]string {
	return map_ClusterClaimList
}

var map_ClusterClaimSpec = map[string]string{
	"value": "Value is a claim-dependent string",
}

func (ClusterClaimSpec) SwaggerDoc() map[string]string {
	return map_ClusterClaimSpec
}

var map_AddOnPlacementScore = map[string]string{
	"":       "AddOnPlacementScore represents a bundle of scores of one managed cluster, which could be used by placement. AddOnPlacementScore is a namespace scoped resource. The namespace of the resource is the cluster namespace.",
	"status": "Status represents the status of the AddOnPlacementScore.",
}

func (AddOnPlacementScore) SwaggerDoc() map[string]string {
	return map_AddOnPlacementScore
}

var map_AddOnPlacementScoreItem = map[string]string{
	"":      "AddOnPlacementScoreItem represents the score name and value.",
	"name":  "Name is the name of the score",
	"value": "Value is the value of the score. The score range is from -100 to 100.",
}

func (AddOnPlacementScoreItem) SwaggerDoc() map[string]string {
	return map_AddOnPlacementScoreItem
}

var map_AddOnPlacementScoreList = map[string]string{
	"":         "AddOnPlacementScoreList is a collection of AddOnPlacementScore.",
	"metadata": "Standard list metadata. More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds",
	"items":    "Items is a list of AddOnPlacementScore",
}

func (AddOnPlacementScoreList) SwaggerDoc() map[string]string {
	return map_AddOnPlacementScoreList
}

var map_AddOnPlacementScoreStatus = map[string]string{
	"":           "AddOnPlacementScoreStatus represents the current status of AddOnPlacementScore.",
	"conditions": "Conditions contain the different condition statuses for this AddOnPlacementScore.",
	"scores":     "Scores contain a list of score name and value of this managed cluster.",
	"validUntil": "ValidUntil defines the valid time of the scores. After this time, the scores are considered to be invalid by placement. nil means never expire. The controller owning this resource should keep the scores up-to-date.",
}

func (AddOnPlacementScoreStatus) SwaggerDoc() map[string]string {
	return map_AddOnPlacementScoreStatus
}

var map_MandatoryDecisionGroup = map[string]string{
	"":           "MandatoryDecisionGroup set the decision group name or group index. GroupName is considered first to select the decisionGroups then GroupIndex.",
	"groupName":  "GroupName of the decision group should match the placementDecisions label value with label key cluster.open-cluster-management.io/decision-group-name",
	"groupIndex": "GroupIndex of the decision group should match the placementDecisions label value with label key cluster.open-cluster-management.io/decision-group-index",
}

func (MandatoryDecisionGroup) SwaggerDoc() map[string]string {
	return map_MandatoryDecisionGroup
}

var map_MandatoryDecisionGroups = map[string]string{
	"":                        "MandatoryDecisionGroups",
	"mandatoryDecisionGroups": "List of the decision groups names or indexes to apply the workload first and fail if workload did not reach successful state. GroupName or GroupIndex must match with the decisionGroups defined in the placement's decisionStrategy",
}

func (MandatoryDecisionGroups) SwaggerDoc() map[string]string {
	return map_MandatoryDecisionGroups
}

var map_RolloutAll = map[string]string{
	"": "RolloutAll is a RolloutStrategy Type",
}

func (RolloutAll) SwaggerDoc() map[string]string {
	return map_RolloutAll
}

var map_RolloutProgressive = map[string]string{
	"":               "RolloutProgressive is a RolloutStrategy Type",
	"maxConcurrency": "MaxConcurrency is the max number of clusters to deploy workload concurrently. The default value for MaxConcurrency is determined from the clustersPerDecisionGroup defined in the placement->DecisionStrategy.",
}

func (RolloutProgressive) SwaggerDoc() map[string]string {
	return map_RolloutProgressive
}

var map_RolloutProgressivePerGroup = map[string]string{
	"": "RolloutProgressivePerGroup is a RolloutStrategy Type",
}

func (RolloutProgressivePerGroup) SwaggerDoc() map[string]string {
	return map_RolloutProgressivePerGroup
}

var map_RolloutStrategy = map[string]string{
	"":                    "Rollout strategy to apply workload to the selected clusters by Placement and DecisionStrategy.",
	"type":                "Rollout strategy Types are All, Progressive and ProgressivePerGroup 1) All means apply the workload to all clusters in the decision groups at once. 2) Progressive means apply the workload to the selected clusters progressively per cluster. The workload will not be applied to the next cluster unless one of the current applied clusters reach the successful state or timeout. 3) ProgressivePerGroup means apply the workload to decisionGroup clusters progressively per group. The workload will not be applied to the next decisionGroup unless all clusters in the current group reach the successful state or timeout.",
	"all":                 "All define required fields for RolloutStrategy type All",
	"progressive":         "Progressive define required fields for RolloutStrategy type Progressive",
	"progressivePerGroup": "ProgressivePerGroup define required fields for RolloutStrategy type ProgressivePerGroup",
}

func (RolloutStrategy) SwaggerDoc() map[string]string {
	return map_RolloutStrategy
}

var map_Timeout = map[string]string{
	"":        "Timeout to consider while applying the workload.",
	"timeout": "Timeout define how long workload applier controller will wait till workload reach successful state in the cluster. Timeout default value is None meaning the workload applier will not proceed apply workload to other clusters if did not reach the successful state. Timeout must be defined in [0-9h]|[0-9m]|[0-9s] format examples; 2h , 90m , 360s",
}

func (Timeout) SwaggerDoc() map[string]string {
	return map_Timeout
}

// AUTO-GENERATED FUNCTIONS END HERE
